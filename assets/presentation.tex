\documentclass[aspectratio=169]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algorithmic}

% Настройка темы
\usetheme{Madrid}
\usecolortheme{default}

% Настройка подсветки кода
\lstset{
    language=Python,
    basicstyle=\tiny\ttfamily,
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    commentstyle=\color{green!60!black},
    numbers=left,
    numberstyle=\tiny,
    breaklines=true,
    frame=single,
    showstringspaces=false,
    extendedchars=true,
    inputencoding=utf8,
    keepspaces=true,
    linewidth=\textwidth,
    numbersep=5pt, % Distance between numbers and code
    xleftmargin=1.5em, % Indent the code from the left edge of the frame
    framexleftmargin=0pt, % Align the frame with the text margin
}

% Информация о презентации
\title[HFE Криптосистема]{Реализация алгоритмов шифрования и расшифрования\\для криптосистемы HFE}
\subtitle{Параллельные вычисления}
\author{ИУ8-112}
\institute{МГТУ им. Н.Э. Баумана}
\date{\today}

\begin{document}

% Титульный слайд
\begin{frame}
\titlepage
\end{frame}

% ============================================
% РАЗДЕЛ 1: ВВЕДЕНИЕ В HFE
% ============================================

\section{Введение в HFE}

\begin{frame}{Что такое HFE?}
\begin{itemize}
    \item \textbf{HFE (Hidden Field Equations)} — криптографическая система с открытым ключом
    \item Предложена Жаком Патарином в 1996 году
    \item Основана на многочленных уравнениях над конечными полями
    \item Использует скрытую структуру конечного поля для обеспечения безопасности
\end{itemize}

\vspace{0.5cm}
\begin{block}{Основная идея}
Преобразование сложных уравнений над конечным полем в систему квадратичных уравнений над GF(2)
\end{block}
\end{frame}

\begin{frame}{Математические основы}
\begin{columns}
\column{0.5\textwidth}
\textbf{Конечное поле GF(2$^n$)}
\begin{itemize}
    \item Поле размерности $n$
    \item $2^n$ элементов
    \item Операции: сложение (XOR), умножение по модулю неприводимого многочлена
    \item Неприводимый многочлен: $x^n + \ldots + 1$
\end{itemize}

\column{0.5\textwidth}
\textbf{HFE многочлен}
\begin{itemize}
    \item $P(x) = \sum_{i \leq j \leq d} a_{ij} \cdot x^{2^i + 2^j}$
    \item Степень $d$ ограничена
    \item Коэффициенты $a_{ij} \in$ GF(2$^n$)
\end{itemize}
\end{columns}

\vspace{0.5cm}
\begin{alertblock}{Важно}
Для расшифрования необходимо решить уравнение $P(x) = y$, что требует знания секретной структуры
\end{alertblock}
\end{frame}

\begin{frame}{Структура HFE криптосистемы}
\begin{center}
\Large
Открытый текст $\rightarrow$ $S$ $\rightarrow$ $P(x)$ $\rightarrow$ $T$ $\rightarrow$ Шифротекст
\end{center}

\vspace{0.5cm}
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
Открытый текст & $S$ & HFE многочлен & $T$ & Шифротекст \\
\hline
\end{tabular}
\end{center}

\vspace{0.5cm}
\textbf{Алгоритм шифрования:}
\begin{enumerate}
    \item Применение секретного аффинного преобразования $S$: $x' = S_1 \cdot x + S_0$
    \item Вычисление HFE многочлена: $y' = P(x')$
    \item Применение секретного аффинного преобразования $T$: $y = T_1 \cdot y' + T_0$
\end{enumerate}
\end{frame}

\begin{frame}{Алгоритм расшифрования}
\begin{enumerate}
    \item \textbf{Обратное преобразование $T$}: $y' = T_1^{-1} \cdot (y - T_0)$
    \item \textbf{Решение HFE уравнения}: найти $x'$ такой, что $P(x') = y'$
    \begin{itemize}
        \item Требует перебора или знания структуры многочлена
        \item В нашей реализации используется перебор всех возможных значений
    \end{itemize}
    \item \textbf{Обратное преобразование $S$}: $x = S_1^{-1} \cdot (x' - S_0)$
\end{enumerate}

\vspace{0.5cm}
\begin{alertblock}{Вычислительная сложность}
Решение HFE уравнения — самая затратная операция, требует $O(2^n)$ операций в худшем случае
\end{alertblock}
\end{frame}

% ============================================
% РАЗДЕЛ 2: ОБЫЧНАЯ РЕАЛИЗАЦИЯ
% ============================================

\section{Обычная реализация}

\begin{frame}{Архитектура обычной реализации}
\begin{block}{Основные компоненты}
\begin{itemize}
    \item \texttt{GF2n} — класс для работы с конечным полем GF(2$^n$)
    \item \texttt{HFEBase} — базовая реализация HFE
    \item Последовательная обработка данных
\end{itemize}
\end{block}

\vspace{0.3cm}
\textbf{Последовательность операций:}
\begin{enumerate}
    \item Инициализация: генерация ключей (матрицы $S_1, S_0, T_1, T_0$)
    \item Для каждого байта данных:
    \begin{itemize}
        \item Преобразование байта в вектор бит
        \item Применение $S$, вычисление $P(x)$, применение $T$
        \item Преобразование результата обратно в байт
    \end{itemize}
\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Что выполняется последовательно?}
\begin{lstlisting}
def encrypt_block(self, data: bytes) -> bytes:
    result = []
    for byte_val in data:  # Sequential processing
        # Convert byte to bit vector
        plaintext = [(byte_val >> i) & 1 
                     for i in range(self.n)]
        
        # Encrypt single byte
        ciphertext = self.encrypt(plaintext)
        
        # Convert back to byte
        cipher_byte = sum(bit << i 
                         for i, bit in enumerate(ciphertext))
        result.append(cipher_byte)
    
    return bytes(result)
\end{lstlisting}

\vspace{0.3cm}
\begin{alertblock}{Узкое место}
Каждый байт обрабатывается независимо, но выполнение происходит последовательно на одном ядре CPU
\end{alertblock}
\end{frame}

\begin{frame}{Вычислительная сложность}
\begin{columns}
\column{0.5\textwidth}
\textbf{Шифрование одного байта:}
\begin{itemize}
    \item Аффинное преобразование $S$: $O(n^2)$
    \item HFE многочлен: $O(d)$
    \item Аффинное преобразование $T$: $O(n^2)$
    \item \textbf{Итого:} $O(n^2 + d)$
\end{itemize}

\column{0.5\textwidth}
\textbf{Расшифрование одного байта:}
\begin{itemize}
    \item Обратное $T$: $O(n^2)$
    \item Решение HFE: $O(2^n)$ — перебор!
    \item Обратное $S$: $O(n^2)$
    \item \textbf{Итого:} $O(2^n)$
\end{itemize}
\end{columns}

\vspace{0.5cm}
\textbf{Для $N$ байт:} $O(N \cdot (n^2 + d))$ для шифрования, $O(N \cdot 2^n)$ для расшифрования
\end{frame}

% ============================================
% РАЗДЕЛ 3: CPU-ПАРАЛЛЕЛИЗАЦИЯ
% ============================================

\section{CPU-параллелизация}

\begin{frame}{Подход к CPU-параллелизации}
\begin{block}{Используемая технология}
\texttt{multiprocessing} — создание нескольких процессов Python для параллельной обработки
\end{block}

\vspace{0.3cm}
\textbf{Стратегия распараллеливания:}
\begin{enumerate}
    \item Разделение данных на \textbf{chunks} (части)
    \item Каждый процесс обрабатывает свой chunk независимо
    \item Объединение результатов
\end{enumerate}

\vspace{0.3cm}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
Процесс 1 & Процесс 2 & Процесс 3 & Процесс 4 \\
\hline
Байты 0-255 & Байты 256-511 & Байты 512-767 & Байты 768-1023 \\
\hline
\end{tabular}
\end{center}
\end{frame}

\begin{frame}[fragile]{Что конкретно распараллелено?}
\begin{lstlisting}
def encrypt_block(self, data: bytes) -> bytes:
    # Convert all bytes to vectors
    plaintexts = [[(byte_val >> i) & 1 
                   for i in range(self.n)] 
                  for byte_val in data]
    
    # Split into chunks
    chunk_size = len(plaintexts) // num_processes
    chunks = [plaintexts[i:i + chunk_size] 
              for i in range(0, len(plaintexts), chunk_size)]
    
    # PARALLEL PROCESSING
    with Pool(processes=num_processes) as pool:
        results = pool.map(_encrypt_chunk_worker, chunks)
    
    # Merge results
    ciphertexts = []
    for chunk_result in results:
        ciphertexts.extend(chunk_result)
\end{lstlisting}
\end{frame}

\begin{frame}{Детали распараллеливания}
\begin{block}{Распараллеленные операции}
\begin{itemize}
    \item \textbf{Обработка независимых байтов} — каждый процесс шифрует свой набор байтов
    \item \textbf{Аффинные преобразования} — выполняются параллельно для разных данных
    \item \textbf{Вычисление HFE многочлена} — параллельно для разных входных значений
    \item \textbf{Решение HFE уравнений} — параллельно при расшифровании
\end{itemize}
\end{block}

\vspace{0.3cm}
\begin{alertblock}{Что НЕ распараллелено}
\begin{itemize}
    \item Генерация ключей (выполняется один раз)
    \item Преобразование данных между форматами (вектор $\leftrightarrow$ байт)
    \item Объединение результатов (последовательное)
\end{itemize}
\end{alertblock}
\end{frame}

\begin{frame}{Архитектура CPU-параллельной версии}
\begin{center}
\begin{tabular}{c}
Входные данные \\
$\downarrow$ \\
Разделение на chunks \\
$\downarrow$ \\
\begin{tabular}{ccc}
Процесс 1 & Процесс 2 & Процесс 3 \\
Chunk 1 & Chunk 2 & Chunk 3 \\
\end{tabular} \\
$\downarrow$ \\
Объединение результатов \\
$\downarrow$ \\
Выходные данные \\
\end{tabular}
\end{center}

\vspace{0.3cm}
\textbf{Преимущества:}
\begin{itemize}
    \item Использование всех ядер CPU
    \item Линейное ускорение (до количества ядер)
    \item Независимость процессов (изоляция ошибок)
\end{itemize}
\end{frame}

\begin{frame}{Оценка производительности CPU-версии}
\begin{block}{Теоретическое ускорение}
Для $P$ процессов: ускорение $\approx P \times$ (с учетом накладных расходов)
\end{block}

\vspace{0.3cm}
\textbf{Накладные расходы:}
\begin{itemize}
    \item Создание процессов: $\sim 10-50$ мс
    \item Передача данных между процессами
    \item Синхронизация и объединение результатов
\end{itemize}

\vspace{0.3cm}
\textbf{Эффективность:}
\begin{itemize}
    \item Для больших данных ($> 1$ KB): эффективность $\approx 80-95\%$
    \item Для малых данных ($< 100$ байт): накладные расходы могут превысить выгоду
\end{itemize}
\end{frame}

% ============================================
% РАЗДЕЛ 4: GPU-ПАРАЛЛЕЛИЗАЦИЯ
% ============================================

\section{GPU-параллелизация}

\begin{frame}{Подход к GPU-параллелизации}
\begin{block}{Используемая технология}
\texttt{PyTorch} — высокоуровневая библиотека для тензорных вычислений на GPU с автоматической оптимизацией
\end{block}

\vspace{0.3cm}
\textbf{Архитектура GPU:}
\begin{itemize}
    \item Тысячи потоков (2048-8192+)
    \item SIMT (Single Instruction Multiple Threads)
    \item Высокая пропускная способность для параллельных операций
    \item Пакетная обработка (batch processing) для минимизации накладных расходов
\end{itemize}

\vspace{0.3cm}
\begin{alertblock}{Особенность}
GPU оптимален для больших объемов данных и однотипных операций. PyTorch обеспечивает автоматическую оптимизацию доступа к памяти
\end{alertblock}
\end{frame}

\begin{frame}[fragile]{Что конкретно распараллелено на GPU?}
\begin{lstlisting}
# Batch encryption using PyTorch tensors
def encrypt_batch(self, plaintexts: torch.Tensor) -> torch.Tensor:
    # Step 1: Apply S (matrix multiplication on GPU)
    x = self._affine_transform_gpu(plaintexts, self.S1_gpu, self.S0_gpu)
    x_field = self.gpu_field.vector_to_field(x)
    
    # Step 2: Apply HFE polynomial (parallel for the whole batch)
    y_field = self._hfe_polynomial_gpu(x_field)
    y = self.gpu_field.field_to_vector(y_field)
    
    # Step 3: Apply T (matrix multiplication on GPU)
    ciphertexts = self._affine_transform_gpu(y, self.T1_gpu, self.T0_gpu)
    return ciphertexts

# Affine transformation with type optimization
def _affine_transform_gpu(self, x, A, b):
    x_float = x.float()  # Convert for matmul
    y = (x_float @ A.T + b.unsqueeze(0)) % 2
    return (y.long() % 2).long()  # Back to int64
\end{lstlisting}
\end{frame}

\begin{frame}{Распараллеленные операции на GPU}
\begin{block}{Полностью распараллелено (оптимизировано):}
\begin{itemize}
    \item \textbf{Аффинные преобразования} — матричное умножение через PyTorch (автоматическая оптимизация)
    \item \textbf{Вычисление HFE многочлена} — параллельно для всего батча через тензорные операции
    \item \textbf{Операции над полями GF(2$^n$)} — битовые операции (XOR, AND, сдвиги) на GPU
    \item \textbf{Преобразования бит<->поле} — векторные операции PyTorch
    \item \textbf{Пакетная обработка} — обработка батчей размером 1024+ элементов одновременно
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Распараллеленные операции на GPU}
\begin{alertblock}{Параллельное решение HFE уравнений:}
\begin{itemize}
    \item \textbf{Параллельный перебор} — для малых полей (n $\leq$ 8) создается сетка всех возможных значений
    \item \textbf{Векторизованное вычисление} — P(x) вычисляется для всех x одновременно
    \item \textbf{Поиск совпадений} — через тензорные операции сравнения
    \item Для больших полей используется fallback на CPU
\end{itemize}
\end{alertblock}
\end{frame}

\begin{frame}{Архитектура GPU-параллельной версии}
\begin{center}
\begin{tabular}{c}
CPU: Подготовка данных \\
(байты $\rightarrow$ векторы бит) \\
$\downarrow$ \\
Создание PyTorch тензоров \\
$\downarrow$ \\
Передача CPU $\rightarrow$ GPU \textcolor{gray}{\texttt{torch.tensor(..., device='cuda')}} \\
$\downarrow$ \\
GPU: Параллельная обработка батчами \\
(Тысячи потоков, тензорные операции) \\
$\downarrow$ \\
Передача GPU $\rightarrow$ CPU \textcolor{gray}{\texttt{tensor.cpu().numpy()}} \\
$\downarrow$ \\
CPU: Объединение результатов \\
(векторы бит $\rightarrow$ байты) \\
\end{tabular}
\end{center}
\end{frame}

\begin{frame}{Архитектура GPU-параллельной версии}
\textbf{Этапы обработки:}
\begin{enumerate}
    \item Преобразование данных на CPU (байты $\rightarrow$ векторы бит)
    \item Разделение на батчи (размер батча: 1024 по умолчанию)
    \item Создание PyTorch тензоров и копирование на GPU
    \item Параллельное выполнение тензорных операций на GPU
    \begin{itemize}
        \item Матричные умножения (float32 для эффективности)
        \item Битовые операции над полем GF(2$^n$) (int64)
        \item Векторизованные вычисления HFE многочлена
    \end{itemize}
    \item Копирование результатов обратно на CPU
    \item Преобразование обратно в байты
\end{enumerate}
\end{frame}

\begin{frame}{Ключевые компоненты GPU-реализации}
\begin{block}{Основные классы и методы:}
\begin{itemize}
    \item \texttt{GF2nGPU} — операции над полем GF(2$^n$) на GPU
    \begin{itemize}
        \item \texttt{add()} — XOR операция (битовая)
        \item \texttt{multiply()} — умножение с приведением по модулю
        \item \texttt{power()} — быстрое возведение в степень
        \item \texttt{vector\_to\_field()} / \texttt{field\_to\_vector()} — преобразования
    \end{itemize}
    \item \texttt{HFEGPUParallel} — основная реализация HFE на GPU
    \begin{itemize}
        \item \texttt{encrypt\_batch()} — пакетное шифрование
        \item \texttt{decrypt\_batch()} — пакетное расшифрование
        \item \texttt{\_affine\_transform\_gpu()} — аффинные преобразования
        \item \texttt{\_solve\_hfe\_gpu()} — параллельное решение HFE уравнений
    \end{itemize}
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Оптимизации PyTorch реализации}
\begin{block}{Примененные оптимизации:}
\begin{itemize}
    \item \textbf{Пакетная обработка} — обработка батчей 1024+ элементов для минимизации накладных расходов
    \item \textbf{Оптимизация типов данных} — float32 для матричных операций (CUDA не поддерживает Long для matmul)
    \item \textbf{Автоматическая оптимизация памяти} — PyTorch обеспечивает коалесцированный доступ
    \item \textbf{Векторизованные операции} — все операции выполняются над тензорами параллельно
    \item \textbf{Параллельный перебор} — для решения HFE уравнений создается сетка всех возможных значений
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Оптимизации PyTorch реализации}
\begin{alertblock}{Требования}
\begin{itemize}
    \item Требуется NVIDIA GPU с CUDA и PyTorch с поддержкой CUDA
    \item Накладные расходы на передачу данных минимизированы пакетной обработкой
    \item Эффективно для данных $> 1$ KB благодаря пакетной обработке
\end{itemize}
\end{alertblock}
\end{frame}

\begin{frame}{Оценка производительности GPU-версии}
\begin{block}{Теоретическое ускорение}
Для больших данных ($> 10$ MB): ускорение $\approx 15-120 \times$ по сравнению с CPU
\end{block}

\vspace{0.1cm}
\textbf{Факторы производительности:}
\begin{itemize}
    \item \textbf{Размер батча:} чем больше батч, тем эффективнее использование GPU
    \item \textbf{Пропускная способность памяти:} PyTorch автоматически оптимизирует доступ
    \item \textbf{Вычислительная мощность:} тысячи потоков работают параллельно через тензорные операции
    \item \textbf{Пакетная обработка:} минимизирует накладные расходы на передачу данных
\end{itemize}

\vspace{0.1cm}
\textbf{Преимущества PyTorch:}
\begin{itemize}
    \item Автоматическая оптимизация операций
    \item Эффективное использование памяти GPU
    \item Простота реализации и отладки
    \item Гибкость в выборе типов данных (float32 для matmul, int64 для битовых операций)
\end{itemize}
\end{frame}

% ============================================
% РАЗДЕЛ 5: СРАВНЕНИЕ
% ============================================

\section{Сравнение реализаций}

\begin{frame}{Сравнение подходов}
\begin{table}[h]
\centering
\small
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Характеристика} & \textbf{Обычная} & \textbf{CPU} & \textbf{GPU} \\
\hline
Ядра/Потоки & 1 & 4-16 & 2048-8192+ \\
\hline
Накладные расходы & Минимальные & Средние & Высокие \\
\hline
Оптимальный размер данных & Любой & $> 1$ KB & $> 10$ MB \\
\hline
Ускорение (теоретическое) & 1$\times$ & 4-16$\times$ & 10-100$\times$ \\
\hline
Сложность реализации & Низкая & Средняя & Высокая \\
\hline
Требования & - & Многоядерный CPU & NVIDIA GPU + CUDA \\
\hline
\end{tabular}
\end{table}

\vspace{0.3cm}
\begin{alertblock}{Вывод}
Выбор реализации зависит от размера данных и доступного оборудования
\end{alertblock}
\end{frame}

\begin{frame}{Что распараллелено в каждой версии?}
\begin{columns}
\column{0.26\textwidth}
\textbf{Обычная}
\begin{itemize}
    \item Ничего
    \item Последовательная обработка байтов
    \item Одно ядро CPU
\end{itemize}

\column{0.32\textwidth}
\textbf{CPU}
\begin{itemize}
    \item Обработка независимых байтов
    \item Аффинные преобразования
    \item HFE многочлен
    \item Решение HFE уравнений
\end{itemize}

\column{0.4\textwidth}
\textbf{GPU}
\begin{itemize}
    \item Аффинные преобразования (тензорные операции)
    \item HFE многочлен (векторизованные вычисления)
    \item Операции над полями (битовые операции на GPU)
    \item Решение HFE (параллельный перебор)
    \item Пакетная обработка, автоматическая оптимизация
\end{itemize}
\end{columns}

\vspace{0.5cm}
\begin{center}
\textbf{Все версии распараллеливают обработку независимых блоков данных}
\end{center}
\end{frame}

\begin{frame}{График производительности (теоретический)}
\begin{center}
\textbf{Зависимость времени выполнения от размера данных}
\end{center}

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Размер данных} & \textbf{Обычная} & \textbf{CPU} & \textbf{GPU (PyTorch)} \\
\hline
$< 1$ KB & \textcolor{blue}{Быстро} & Средне & Средне \\
\hline
1 KB - 10 MB & Медленно & \textcolor{red}{Быстро} & \textcolor{green!60!black}{Быстро} \\
\hline
$> 10$ MB & Очень медленно & Медленно & \textcolor{green!60!black}{Очень быстро} \\
\hline
\end{tabular}
\end{center}

\begin{alertblock}{Оптимальная точка перехода}
Для данных $> 1$ KB CPU-версия начинает превосходить обычную\\
GPU-версия эффективна для данных $> 1$ KB благодаря пакетной обработке (batch size = 1024)
\end{alertblock}

\textbf{Наблюдения:}
\begin{itemize}
    \item Для малых данных: обычная версия быстрее (нет накладных расходов)
    \item Для средних данных: CPU-версия оптимальна
    \item Для больших данных: GPU-версия значительно быстрее благодаря пакетной обработке и параллелизму
\end{itemize}
\end{frame}

% ============================================
% РАЗДЕЛ 6: ЗАКЛЮЧЕНИЕ
% ============================================

\section{Заключение}

\begin{frame}{Ключевые моменты}
\begin{block}{HFE криптосистема}
\begin{itemize}
    \item Основана на многочленных уравнениях над GF(2$^n$)
    \item Использует аффинные преобразования для скрытия структуры
    \item Расшифрование требует решения HFE уравнений
\end{itemize}
\end{block}

\vspace{0.3cm}
\begin{block}{Распараллеливание}
\begin{itemize}
    \item \textbf{CPU:} Распараллелена обработка независимых байтов через multiprocessing
    \item \textbf{GPU:} Распараллелены операции через PyTorch тензорные вычисления
    \begin{itemize}
        \item Пакетная обработка для минимизации накладных расходов
        \item Автоматическая оптимизация доступа к памяти PyTorch
        \item Векторизованные операции над полем GF(2$^n$)
        \item Параллельное решение HFE уравнений через перебор на GPU
    \end{itemize}
    \item Обе версии эффективны для больших объемов данных
\end{itemize}
\end{block}
\end{frame}

\end{document}

